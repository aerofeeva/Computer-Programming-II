// Anastasia Erofeeva
// 02/06/16
// CSE 143
// TA: Grace Chen 
// Assignment #5
//
// This program will read from a file with grammar in Backus-Naur Form and 
// allow the user to randomly generate elements of the grammar to create 
// words, phrases or sentences.

import java.util.*;

public class GrammarSolver {
   
   // The grammar stored as the associations between nonterminals and terminals. 
   private SortedMap<String, String[]> grammarMap;
   
   // The rules (terminals separated by the "|" characters) of each nonterminal.
   private String[] rules;

   // Takes a grammar as a list of strings and splits it into terminals and 
   // rules. The rules for each nonterminal can consist of terminals, nonterminals,
   // or both. Throws an IllegalArgumentException if the grammar is empty or if 
   // there are two or more entries in the grammar for the same nonterminal. 
   // Does not change the original list of strings. 
   public GrammarSolver(List<String> grammar) {
      if (grammar.isEmpty()) {
         throw new IllegalArgumentException();
      }
      grammarMap = new TreeMap<String, String[]>();
      for (String line: grammar) {
         String[] parts = line.split("::=");
         String nonterminal = parts[0].trim();
         String terminals = parts[1];
         rules = terminals.trim().split("[|]");
         if (grammarMap.containsKey(nonterminal)) {
            throw new IllegalArgumentException();   
         } else {
            grammarMap.put(nonterminal, rules);
         }
      }
   }
   
   // Takes a string symbol and returns whether or not the symbol is a 
   // nonterminal of the grammar. 
   public boolean grammarContains(String symbol) {
      return (grammarMap.containsKey(symbol));
   }
   
   // Takes a string symbol and an integer times and uses the grammar to 
   // generate the given symbol the given number of times. Returns a random
   // sentence generated by using the nonterminal symbol and its rules. 
   // Throws an IllegalArgumentException if the the given symbol is not a 
   // nonterminal of the grammar or if the number of times is less than 0.
   public String[] generate(String symbol, int times) {
      if (!grammarMap.containsKey(symbol) || times < 0) { 
         throw new IllegalArgumentException();
      }
      Random r = new Random();
      String[] results = new String[times];
      for (int i = 0; i < results.length; i++) {
         results[i] = generateString(symbol, r).trim();
      }
      return results;
   }
   
   // Helper method that takes a string symbol and a Random object from the 
   // public generate method above, and checks whether or not the symbol is a 
   // nonterminal of the grammar. If the symbol is not a nonterminal,
   // returns the symbol and a space. Otherwise, if the symbol is a nonterminal,
   // uses the Random object to choose one of the nonterminal's rules. If the 
   // choosen rule has more than one rule contained within it, splits the rules 
   // by spaces and tabs. Uses recursion to generate the string for each rule. 
   // Returns the terminal string for each nonterminal. This method calls itself 
   // and is called in the public generate method above.     
   private String generateString(String symbol, Random r) {
      if (!grammarContains(symbol)) {
         return symbol + " ";
      } else {
         String[] values = grammarMap.get(symbol);
         int random = r.nextInt(values.length); 
         String chosenRule = values[random];
         String[] rule = chosenRule.trim().split("[ \t]+");
         String word = "";
         for (int i = 0; i < rule.length; i++) {
            word += generateString(rule[i], r);        
         }  
         return word;
      }
   }
   
   // Returns all of the nonterminal symbols of the grammar as a comma-separated
   // list of symbols enclosed in square brackets.    
   public String getSymbols() {
      return (grammarMap.keySet().toString());
   }
}
